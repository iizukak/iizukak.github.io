<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dialy on iizukak_blog</title>
    <link>https://iizukak.github.io/tags/dialy/</link>
    <description>Recent content in Dialy on iizukak_blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 26 Aug 2018 22:02:40 +0900</lastBuildDate>
    
	<atom:link href="https://iizukak.github.io/tags/dialy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ゲームボーイに寄り道</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_26/</link>
      <pubDate>Sun, 26 Aug 2018 22:02:40 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_26/</guid>
      <description>ゲームボーイのハードウェアによるエミュレータについて少し調べた。現状コードが公開されているところでいうと、
 FPGABoy  https://github.com/trun/fpgaboy  VerilogBoy  https://github.com/zephray/VerilogBoy   あたりがありそう。
CPU 情報としては
 Gameboy CPU Manual  http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf  VerilogBoy のドキュメント  https://github.com/zephray/VerilogBoy/blob/refactor/doc/cpu.md  DMB Schematics  http://gbdev.gg8.se/wiki/articles/DMG_Schematics   あたりがありそう。
ところで、ソフトウェアではなくハードウェアでゲームボーイを作るのはなぜかというと、
 面白いから 正確なクロックでエミュレートできる  ソフトウェアだと命令になんクロックかかったかとか制御し辛い？  省電力 FPGA ボードが使いやすくなってきているから  というところだろうか。 特に 1 については LSDJ とか使っている人は気にしそうなところではある。
趣味でちゃんと作ろうとしたら何年もかかりそうなやつだなぁ。いくつか既存プロジェクトはあるが、現状で実用レベルに達しているものはなさそうなかんじ。</description>
    </item>
    
    <item>
      <title>J1</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_25/</link>
      <pubDate>Sat, 25 Aug 2018 22:22:27 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_25/</guid>
      <description>J1 今日は J1 の ドキュメント を一通り読んだ。といっても 4p くらいしかない。機械語の命令長はすべて 16 ビットで、
 リテラル ジャンプ 条件付きジャンプ 呼び出し ALU  の 5 つのカテゴリに分かれる。リテラルと判別するのに MSB が 1 かどうかで判定するので、値の最大値は 2 ** 15 - 1 になりそう。ジャンプ、条件付きジャンプ、呼び出しはそれぞれ MSB 3 ビットで判定。アドレス空間は 16 - 3 = 13 ビットとなる。ので、J1 は 8K ワードのメモリ空間を持つ。これが十分化は実際に FORTH でコードを書いてみないとわからなさそうではある。
ところで、FPGA 上で動作する FORTH プロセッサを用意したとして、その上で FORTH 機械語だけではなく FORTH コードそのものをコンパイルするのは必要だろうか。もし必要だとしたら、作成した FORTH プロセッサの上で動作する FORTH インタプリタを FORTH で書く必要がある。どういう場合に使うかというと、スタンドアロンで FORTH を実行したい場合か。デモにはなりそうだけど、そのためにそういった機構を用意するのはやややりすぎ？
簡単さを意識して作ってしまえば、ホストマシンが何らかのかたちで FORTH コードを機械語に変換して、FORTH プロセッサに機械語命令列だけを送りつけることでインタプリタは作れる。MicroPython とかそうなっているのだろうとは思う。</description>
    </item>
    
    <item>
      <title>2018_08_24</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_24/</link>
      <pubDate>Fri, 24 Aug 2018 21:26:36 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_24/</guid>
      <description>ハリスハリス本 SystemVerilog の章が読み終わった。HDL についてはだいぶ復習できた気がする。
Forth CPU 計画 HDL の教科書を読みはしたけど書いたことはあまりないので、小さなプロジェクトを作って試してみたい。それで思いついたのがプログラミング言語 Forth の CPU 。CPU というほど Central であるかどうかは怪しいが、少なくとも Forth 言語 -&amp;gt; Forth アセンブラ -&amp;gt; Forth 機械語に変換して実行するところを HDL で作るのは理屈上ではそれほど難しくなさそうな気がする。
参考になりそうなところでいうと、 J1 Forth CPU とうのがあるようだ。
Forth CPU を単に作るというのでは面白みがあまりないので、次のような特色を考える
 コアは Chisel で実装する Maker 向け実装とする  動作するチップは絞っても良いが、ペリフェラルへのアクセスを十分に確保する  ボードの GPIO へのアクセスは SystemVerilog で書く アセンブラは Scala で実装する 実行時にシリアル通信かなにかでコマンドを実行できる  MicroPython のようなかんじ   実際の構成を考えていきたい。
とりあえず J1 のドキュメントを読む。</description>
    </item>
    
    <item>
      <title>ブロッキング割り当て、ノンブロッキング割り当て</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_23/</link>
      <pubDate>Thu, 23 Aug 2018 22:07:03 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_23/</guid>
      <description>ハリスハリス本 今日も地道に SystemVerilog の章を読み進めた。ブロッキング割り当て、ノンブロッキング割り当てあたり。それらを利用した有限状態マシンの記述。
ノンブロッキング割り当ては、主に組み合わせ回路に使い、ブロッキング回路は順序回路に使う。なぜかといえば、組み合わせ回路においてはどの順で結線されるかという情報を制御する必要がある。例えば全加算器で、もしノンブロッキングだと、キャリーと出力値が非同期に切り替わり、意図しない出力のタイミングが生じる、などの不都合が生じる。逆に、順序回路ではクロックやリセットなどの立ち上がりエッジ単位で一括で処理を実施する必要がある。
Verilog と System Verilog の違いについても少し。reg や wire といった信号線の宣言が、System Verilog では logic に集約されたり、などなど。
しかしハリスハリス本は A4 サイズでけっこうかさばる。電車の中で立って読もうとするとけっこう厳しい。電子書籍ならよいのだろうか。</description>
    </item>
    
    <item>
      <title>反脆弱プログラマ</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_22/</link>
      <pubDate>Wed, 22 Aug 2018 21:51:25 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_22/</guid>
      <description>反脆弱性を備えたプログラマとは 反脆弱プログラマはどういうものか考えてみたい。
脆いプログラマというのがどいうものかというと、特定のプラットフォームやシステムに特化し長い年月に渡ってその対象のみをエンジニアリングした結果、その対象以外のことに興味がなくなってしまった人物である。そのシステムは不意に無くなったりする。そのような対象を持てる企業はおそらく大きく安定しているとみなされているので、プログラマにとっては不意打ちになりうる。しかし企業はプログラマの事情とは関係なく、便利で汎用的なツールで、その企業でしか使えない保守にコストのかかるシステムを置き換えてしまうだろう。この場合このプログラマは脆い。特定の企業の中の、さらに特定の部門でのみ使われているシステムというのはいくらでも存在する。
現在手回し計算機の仕事を見つけるのは非常に困難だろう。面白くても仕事がなくなることもある。
何でも屋のプログラマで、インフラからフロントエンドまで広く浅くこなす人物が反脆いかというと、これも違う気がする。なぜならそのような何でも屋というのはなろうと思えば誰でもなれるので競争が激しく、より体力のあるだけのプログラマに負ける可能性があるからである。何でも屋をやっていく上ではひとつの技術領域に大幅な時間を使うことはあまりできないので、何でも屋業界では似たり寄ったりなスキルの人ばかりになってしまう。
では反脆いプログラマというのがどういうものかといえば、ある程度の専門性がありつつも、常に技術領域を広げ、中長期的なスパンで必要とされる技術を乗り換えていける人物だろうか。この乗換は 5-10 年といいったスパンか。反脆いプログラマは現在プロフェッショナルとして活動する領域が廃れるまえに、別の領域に乗り換える。乗り換えを先んじて行うことで先行者利益を得る。ときにはその領域に費やした時間が無為となるケースもあるが、いくつかの領域での成功があるのであれば許容できる失敗である。
ハリスハリス本 SystemVerilog の章を読み進める。 always_ff など順序回路の構築に必要な要素を学んだ。FPGA プログラミング大全に入る前に SystemVerilog の章だけでも読んでしまったほうが良さそう。
小児科の先生夏休み 今日は小児科へ。普段は小児科の先生は二人体制なのだが今日は先生が一人夏休みでいらっしゃらなかったので割と待ってしまった。無事薬をもらえてよかった。</description>
    </item>
    
    <item>
      <title>2018_08_21</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_21/</link>
      <pubDate>Tue, 21 Aug 2018 21:23:50 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_21/</guid>
      <description>TinyFPGA が日本でも買えるように。取り寄せだけど TinyFPGA という Lattice の FPGA が乗った基板があるのですが、これがスイッチサイエンスから取り寄せ可能になったらしい。これはほしい。Lattice の FPGA 一枚も持っていないし…
たぶん Maker 向けの製品なのだろうと思うのですが、具体的にはどんな用途を想定しているのだろうか。信号処理系なのかなぁ。レイテンシが必要とされるような楽器みたいなものには使えそうな気はする。映像の処理に使おうと思ったら非力そう。Raspberry Pi とくっつけて、センサの入力を並列で受け取るみたいなのはできそう。まぁいろいろ使い勝手はあるのかな。純粋に HDL の練習用にもよさそう。RISC-V が動くのかな、厳しいかな。
もう少ししたら取り寄せではなくどこかで一般販売されるような気もするので、とりあえずそれを待つ。
ハリスハリス本読み進める SystemVerilog の章を地道に読み勧めている。今月中に読み終わればいいなくらい。FPGA プログラミング大全は、HDL わかっている前提なので、ハリスハリスの本で予習しておこうという次第。構造化プログラミングとか遅延とかあたり。本を読もうと思うと会社の昼休みを駆使することになり、必然的にお昼ご飯がコンビニかパン的なものになってしまうので、なにか朝買えて冷蔵庫にしまっておける、栄養によさそうなものがあればいいのだけれど。
Arty Z7 こちらは特にきょうはやっていない。ジャンパの設定を読み進めるくらい。
AWS F1 インスタンスでアクセラレータ、面白そう 最近は Domain Specific Architecture という概念が今後のコンピューティング界隈で重要になっていくという妄想があって、そうなったらよいなぁと思って FPGA をさわったりしている。AWS F1 インスタンスというのが去年でて、これは FPGA をクラウド上で使えるというやつ。Xilinx の UltraScale が使えるようなので、個人で UltraScale の FPGA ボードを買うよりも全然コスパはよさそう。
ググってもあまり導入しました、みたいな記事はでてこない。試してみた系はちらほら。FPGA でアクセラレータ作ったとかかなりかっこいいのでどんどん公開してほしいなぁと思ったり。
個人的にも、何かのアルゴリズムのアクセラレータを作ってみたい気持ちはある。ターゲットは未定。</description>
    </item>
    
    <item>
      <title>Arty Z7 で L チカ</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_20/</link>
      <pubDate>Mon, 20 Aug 2018 21:22:03 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_20/</guid>
      <description>L チカ Arty Z7 を買ったのでとりあえず L チカするところまでやった。メーカーの Digilent が親切な チュートリアル を出しているので、それに従って手順を実行するだけ。Vivado とボードの設定ファイルのインストール方法は 別ドキュメント になっている。
Xilinx の FPGA の IDE であるところの Vivado が 20GB もストレージ容量を使ってびっくりなんですが、他にびっくりしている人はあんまりいなそうなので、こんなもんなのだろうか。いまはネイティブの Windows マシンではなくて、Mac に 64GB のパーティションを切って Windows 10 をインストールしているので、Vivado に 20GB もっていかれると割と容量がカツカツになってしまう。ネイティブの Windows マシンが一台あってもよいなと思うのだけれど、ほしいスペックまであげると、20 万円コースだからなぁ。限界まで Bootcamp で粘ることになりそう。
HDMI 出力デモ Arty Z7 に HDMI 出力のデモが ある ので、こちらもビルドしてみようとしたのだけれど、これが動かない。フォーラムを検索したところ 2016.4 の Vivado でしか動かないとのこと。最新が 2018.2 なので自分はこれを使っているのでした。ボード作っているメーカーが最新の IDE に対応する気配がないのはいただけないような気がするのだけれど。少し直せないかなと頑張ってみたものの動かなさそう。
でも HDMI 出力はしたいので、HDMI の規格を調べ始めたりしていた。
GPD Win 別件で会社で昼休みに趣味開発したい、という思いがあるので GPD Win がほしい気もするが、こっちも 8 万円とかするし、ガシガシ使うかと言われれば微妙な気はする。SSD は 128GB あるようなので、Vivado 使っても安心&amp;hellip;?</description>
    </item>
    
    <item>
      <title>Hugo でこのサイトを構築した</title>
      <link>https://iizukak.github.io/dialy/2018/2018_08_19/</link>
      <pubDate>Sun, 19 Aug 2018 21:27:25 +0900</pubDate>
      
      <guid>https://iizukak.github.io/dialy/2018/2018_08_19/</guid>
      <description>定期的にブログ的なものを作ってみたくなるのはしょうがないことで、今回は Hugo を使って作ってみたのがこのサイトです。Hugo に関しては公式以外にも情報がたくさん出ているのだけれど、公式のドキュメントがしっかりしていて、公式のドキュメントだけで環境構築できたのですが、一応メモを残す。
Windows でのインストール 今回は Windows 10 で環境を作った。公式のドキュメントは ここ。ソースコードからインストールする方法もあるのだけれど、Github 上でビルド済バイナリが配布されているのでそれを DL して配置して、環境変数 PATH に追加するだけ。インストール時のバージョンは、
$ hugo version Hugo Static Site Generator v0.47 windows/amd64 BuildDate: 2018-08-17T09:15:51Z  リポジトリ構成 Github 上で Hugo でサイトをホスティングする際の ドキュメント も公式が用意してくれている。のでこの通りにやればよかった。きもとしては、ブログのソースコードや設定情報を管理するリポジトリと、サイトのホスティング用のリポジトリを別に管理するところ。管理用リポジトリの publish ディレクトリに、ホスティング用リポジトリを submodule で紐づけておく方式になっている。リポジトリを別にする利点としては、ドラフト版とか未公開にしておきたい記事、設定情報をホスティング用のリポジトリに含めなくてよくなることだと思われる。確かにそういう要望はありそう。
deploy.sh というシェルスクリプトも用意されていて、これを管理用リポジトリのほうに含めておいて、記事をローカルで確認した後で叩くと、ホスティング用の publish ディレクトリが push されて、ホスティングされているサイトにも反映されるという仕組み。
コマンドメモ $ hugo new foo/bar.md  のようなコマンドで記事を作れる。このコマンドを実行すると content/foo/bar.md というファイルが作られる。ディレクトリが存在しない場合は再帰的に作られる。また、拡張子も入れないとだめ。
Markdown ファイルのテンプレートは archetypes/default.md が使われるようだ。
テーマ hugo-classic というテーマを利用させていただいています。シンプルで良い。
設定ファイル リポジトリ直下の config.toml&amp;quot; で様々な設定を記述する。いまの設定は次の通り
baseURL = &amp;quot;https://iizukak.github.io&amp;quot; languageCode = &amp;quot;ja&amp;quot; title = &amp;quot;iizukak_blog&amp;quot; theme = &amp;quot;hugo-classic&amp;quot; [[menu.</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://iizukak.github.io/posts/test/</link>
      <pubDate>Sat, 18 Aug 2018 22:22:41 +0900</pubDate>
      
      <guid>https://iizukak.github.io/posts/test/</guid>
      <description>foobar</description>
    </item>
    
  </channel>
</rss>